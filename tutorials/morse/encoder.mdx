---
custom_edit_url: null
---

import Image from '/src/components/Images.js';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Part 2: Create an App : Encoder

## 1. Introduction

Now that we have a led driver, we will develop the encoder service. The goal is to receive a message from a serial service containing a word with few letters, translate these letters into Morse sequences and send these sequences to the Led.

<div align="center">
  <Image
    src="/img/tutorials/morse/morse-2-1.png"
    darkSrc="/img/tutorials/morse/morse-2-1-dark.png"
  />
</div>

## 2. Create the Encoder service

First create a dedicated folder in the /lib repository with two blanked files:

```bash
cd ./lib/
mkdir Encoder/
cd Encoder/
touch encoder.c encoder.h
```

You can also create it by click right and **new_file** on the **Encoder** folder in the project explorer in VSCode:

<div align="center">
  <Image src="/img/tutorials/morse/morse-2-2.png" />
</div>

Then open encoder.h and copy the following code:

```c
/******************************************************************************
 * @file encoder
 * @brief encoder app
 * @author Luos
 * @version 0.0.0
 ******************************************************************************/
#ifndef ENCODER_H
#define ENCODER_H

#include "luos.h"
#include "stdbool.h"

/*******************************************************************************
 * Definitions
 ******************************************************************************/

/*******************************************************************************
 * Variables
 ******************************************************************************/

/*******************************************************************************
 * Function
 ******************************************************************************/
void Encoder_Init(void);
void Encoder_Loop(void);

#endif /* ENCODER_H */
```

We just declared two functions used to run the service as we did for the Led. Now we will create two implementations for them. Open the encoder.c file and copy the following code:

```c
/******************************************************************************
 * @file encoder
 * @brief encoder app
 * @author Luos
 * @version 0.0.0
 ******************************************************************************/

#include "encoder.h"

/*******************************************************************************
 * Definitions
 ******************************************************************************/

/*******************************************************************************
 * Variables
 ******************************************************************************/
service_t *service;

/*******************************************************************************
 * Function
 ******************************************************************************/
void Encoder_MsgHandler(service_t *service, msg_t *msg);

/******************************************************************************
 * @brief init must be call in project init
 * @param None
 * @return None
 ******************************************************************************/
void Encoder_Init(void)
{
    // service initialization
    revision_t revision = {.major = 1, .minor = 0, .build = 0};
    // Service creation following state profile
    service = Luos_CreateService(Encoder_MsgHandler, LUOS_LAST_TYPE, "encoder_service", revision);
}

/******************************************************************************
 * @brief loop must be call in project loop
 * @param None
 * @return None
 ******************************************************************************/
void Encoder_Loop(void)
{
}

/******************************************************************************
 * @brief manage messages send to the service
 * @param Service which send the message
 * @param msg which send the message
 * @return None
 ******************************************************************************/
void Encoder_MsgHandler(service_t *service, msg_t *msg)
{
}
```

All this code is very similar to the previous chapter, we will not take time to explain it. You can run this new service by calling its API in the **main** file:

```c
/******************************************************************************
 * @brief main function
 * @param None
 * @return None
 ******************************************************************************/
int main(void)
{
    HAL_Init();
    SystemClock_Config();

    // Init
    Luos_Init();
    Led_Init();
    Encoder_Init();
    while (1)
    {
        // Loop
        Luos_Loop();
        Led_Loop();
        Encoder_Loop();
    }
}
```

## 3. Send a Luos message

Now we will create Morse sequences from letters and send them to the Led service. But first we need a function to create and send luos messages. Open encoder.c and add the following in function section:

```c
/*******************************************************************************
 * Function
 ******************************************************************************/
void Encoder_SendMorse(bool state);
```

Then copy the following code at the end of the file:

```c
/******************************************************************************
 * @brief send a luos message to the led
 * @param State to send to the led
 * @return None
 ******************************************************************************/
void Encoder_SendMorse(bool state)
{
    // Now send a message
    if (id_led > 0)
    {
        msg_t led_msg;
        led_msg.header.target = id_led;
        led_msg.header.cmd = IO_STATE;
        led_msg.header.target_mode = IDACK;
        led_msg.header.size = sizeof(char);
        led_msg.data[0] = state;
        Luos_SendMsg(service, &led_msg);
    }
}
```

The argument **state** is used to light **ON/OFF** the led, then we create a **msg_t** variable which we will fill with several informations:

- Target: all services have an **ID** and here we will give the ID of message target.
- Cmd: this field gives information about the data we send
- Target_mode: some low-level luos internal stuff, it gives informations about how the message will be managed.
- Size: the size of sended data
- Data[128]: an array which is used to store data to send

Once the message is created we can send it with the **Luos_SendMsg** routine. It only needs a pointer to the sending service and the message to send.

One problem remaining, how can we find the ID of the target service ? Luos gives you a routine to do this too: the Routing table Filtering method. You will further explain this mechanism in the next steps, when we will define the _led_id_.

## 4. Play a morse letter

Now we will use our new function to create morse sequences for each letter in the alphabet. In morse, each letter can be broken down in several ON / OFF LED states and the duration of these states is defined in the [Morse code - Wikipedia](https://en.wikipedia.org/wiki/Morse_code).

We will create structures to store these states for each letter. First add this in **encoder.h**:

```c
/*******************************************************************************
 * Definitions
 ******************************************************************************/
#define SHORT_PERIOD 300

typedef enum WordLength
{
    SHORT      = SHORT_PERIOD,
    LONG       = 3 * SHORT_PERIOD,
    WORD_SPACE = 7 * SHORT_PERIOD,
} WordLength;

typedef struct MorseElement
{
    union
    {
        struct
        {
            uint16_t state;
            uint16_t word_length;
        };
        uint32_t value;
    };
} MorseElement;

typedef struct MorseLetter
{
    union
    {
        MorseElement morse_element[10];
        uint32_t value;
    };
} MorseLetter;
```

Then, add a new file in **/lib/encoder**:

```bash
touch dictionnary.h
```

And copy the following code in it:

```c
/******************************************************************************
 * @file dictionnary
 * @brief morse dictionnary
 * @author Luos
 * @version 0.0.0
 ******************************************************************************/
#ifndef DICTIONNARY_H
#define DICTIONNARY_H

#include "encoder.h"

/*******************************************************************************
 * Definitions
 ******************************************************************************/
#define LETTER_END 0xFFFFFFF1

/*******************************************************************************
 * Variables
 ******************************************************************************/
MorseLetter a_letter = {
    .morse_element[0]       = {.state = true, .word_length = SHORT},
    .morse_element[1]       = {.state = false, .word_length = SHORT},
    .morse_element[2]       = {.state = true, .word_length = LONG},
    .morse_element[3]       = {.state = false, .word_length = SHORT},
    .morse_element[4].value = LETTER_END,
};

MorseLetter b_letter = {
    .morse_element[0]       = {.state = true, .word_length = LONG},
    .morse_element[1]       = {.state = false, .word_length = SHORT},
    .morse_element[2]       = {.state = true, .word_length = SHORT},
    .morse_element[3]       = {.state = false, .word_length = SHORT},
    .morse_element[4]       = {.state = true, .word_length = SHORT},
    .morse_element[5]       = {.state = false, .word_length = SHORT},
    .morse_element[6]       = {.state = true, .word_length = SHORT},
    .morse_element[7]       = {.state = false, .word_length = SHORT},
    .morse_element[8].value = LETTER_END,
};

MorseLetter c_letter = {
    .morse_element[0]       = {.state = true, .word_length = LONG},
    .morse_element[1]       = {.state = false, .word_length = SHORT},
    .morse_element[2]       = {.state = true, .word_length = SHORT},
    .morse_element[3]       = {.state = false, .word_length = SHORT},
    .morse_element[4]       = {.state = true, .word_length = LONG},
    .morse_element[5]       = {.state = false, .word_length = SHORT},
    .morse_element[6]       = {.state = true, .word_length = SHORT},
    .morse_element[7]       = {.state = false, .word_length = SHORT},
    .morse_element[8].value = LETTER_END,
};

...
```

You can find the complete code in the github repository. Now add the following function in encoder.c:

```c
uint8_t morse_state          = false;
WordLength morse_period      = 0;
uint32_t morse_start_timeout = 0;
uint16_t element_index       = 0;
bool end_of_letter           = true;

...

void Encoder_PlayLetter(MorseLetter *letter);

...

/******************************************************************************
 * @brief Play a letter sequence
 * @param None
 * @return None
 ******************************************************************************/
void Encoder_PlayLetter(MorseLetter *letter)
{
    // for each element in a letter
    if ((letter->morse_element[element_index].value != LETTER_END) & !end_of_letter)
    {
        if (Luos_GetSystick() - morse_start_timeout > morse_period)
        {
            morse_state  = letter->morse_element[element_index].state;
            morse_period = letter->morse_element[element_index].word_length;
            // send new led state
            Encoder_SendMorse(morse_state);
            // wait for the time period
            morse_start_timeout = Luos_GetSystick();
            // go to the next element
            element_index += 1;
        }
    }
    else
    {
        // reset element index and go to the next letter
        element_index = 0;
        end_of_letter = true;
    }
}
```

We will not dig in this code too much because it’s not the purpose of this tutorial. Just notice that this function iterates over each line contained in letter and it stops when it detects the LETTER_END constant.

## 5. Play a morse word

The next step is straightforward, we will use **Encoder_PlayLetter** to create sequences for words.

First, create the word structure, into **encoder.h** file:

```c
...
typedef struct MorseWord
{
    MorseLetter *morse_letter[10];
} MorseWord;
```

Add this in dictionnary.h:

```c
/*******************************************************************************
 * Definitions
 ******************************************************************************/
#define LETTER_END 0xFFFFFFF1
#define WORD_END   0xFFFFFFF2

/*******************************************************************************
 * Variables
 ******************************************************************************/
MorseLetter end_word_marker = {
    .value = WORD_END};

MorseLetter end_letter = {
    .morse_element[0]       = {.state = false, .word_length = WORD_SPACE - SHORT},
    .morse_element[1].value = LETTER_END,
};
```

end_letter is used to wait between two words. WORD_END is used to detect the end of a word in Encoder_PlayWord routine which we will add in encoder.c:

```c
...

uint16_t element_index       = 0;
uint16_t letter_index        = 0;
bool end_of_word             = false;
bool end_of_letter           = true;

...

void Encoder_PlayWord(MorseWord *morse_word);

...

/******************************************************************************
 * @brief Play a word
 * @param None
 * @return None
 ******************************************************************************/
void Encoder_PlayWord(MorseWord *morse_word)
{
    // send a word sequence
    if ((morse_word->morse_letter[letter_index]->value != WORD_END) & !end_of_word)
    {
        Encoder_PlayLetter(morse_word->morse_letter[letter_index]);

        if (end_of_letter)
        {
            end_of_letter = false;
            letter_index += 1;
        }
    }
    else
    {
        // end of word
        letter_index = 0;
        end_of_word  = true;
    }
}
```

## 6. Detect serial service

Now we will add this **Encoder_PlayWord** routine in **Encoder_Loop**. Our service will have two operating modes:

1. If it detects the presence of the serial service, it will play morse words received from it.
2. If not, it will play the sequence S.O.S

To do this, we will use Luos functions:

```c
MorseWord receive_word;

MorseWord sos_table = {
    .morse_letter[0] = &s_letter,
    .morse_letter[1] = &o_letter,
    .morse_letter[2] = &s_letter,
    .morse_letter[3] = &end_letter,
    .morse_letter[4] = &end_word_marker,
};

bool serial_detected = false;

/******************************************************************************
 * @brief loop must be call in project loop
 * @param None
 * @return None
 ******************************************************************************/
void Encoder_Loop(void)
{
    if (Luos_IsNodeDetected())
    {
        if (serial_detected)
        {
            Encoder_PlayWord(&receive_word);
        }
        else
        {
            end_of_word = false;
            Encoder_PlayWord(&sos_table);
        }
    }
}
```

:::info
Notice that we use Luos_IsNodeDetected: this function checks if the node is connected on the luos network. We use this function to not run the service loop function if the node is not connected.
:::

All services have to be connected on the luos network to send and receive messages. For services to be connected and recognized in the network, we have to launch a detection. We do that by adding the following line in the Encoder_Init function:

```c
void Encoder_Init(void)
{
    // service initialization
    revision_t revision = {.major = 1, .minor = 0, .build = 0};
    // Service creation following state profile
    service = Luos_CreateService(Encoder_MsgHandler, LUOS_LAST_TYPE, "encoder_service", revision);
    // Detect all services of your network and create a routing_table
    Luos_Detect(service);

    // initialize variables
    morse_state         = false;
    morse_period        = 0;
    morse_start_timeout = 0;
    element_index       = 0;
    letter_index        = 0;
    end_of_letter       = true;
    end_of_word         = true;
}
```

**Luos_Detect** launches the detection and its end can be detected with **Luos_IsConnected**: once the node is connected, the function returns **true**. After that, all services can send and receive messages.

We added some initialization code too to set default values for variables.

## 7. Receive a custom message from Serial service

One last thing, we have to manage messages received from the serial service to update the received_word variable. As seen in the tutorial for the LED service, messages received by the Encoder are handled by Encoder_MsgHandler. Let’s add the following code in encoder.c:

```c
/******************************************************************************
 * @brief manage messages send to the service
 * @param Service which send the message
 * @param msg which send the message
 * @return None
 ******************************************************************************/
void Encoder_MsgHandler(service_t *service, msg_t *msg)
{
    uint16_t index          = 0;
    uint8_t received_letter = 0;

    if (msg->header.cmd == SET_CMD)
    {
        while (msg->data[index] != '\r')
        {
            receive_word.morse_letter[index] = Encoder_DecodeLetter(msg->data[index]);
            index += 1;
        }
        receive_word.morse_letter[index]     = &end_letter;
        receive_word.morse_letter[index + 1] = &end_word_marker;

        end_of_word = false;
        end_of_letter = false;
    }

		if (msg->header.cmd == END_DETECTION)
    {
        search_result_t result;
        RTFilter_Alias(RTFilter_Reset(&result), "led_service");
        id_led = result.result_table[0]->id;
        RTFilter_Type(RTFilter_Reset(&result), PIPE_TYPE);
        if (result.result_nbr > 0)
        {
            time_luos_t update_time = 0.01;
            msg_t update_msg;
            update_msg.header.target      = result.result_table[0]->id;
            update_msg.header.target_mode = IDACK;
            TimeOD_TimeToMsg(&update_time, &update_msg);
            update_msg.header.cmd = UPDATE_PUB;
            Luos_SendMsg(service, &update_msg);
            serial_detected = true;
            return;
        }
        serial_detected = false;
    }
}
```

First, please pay attention to the second **if** statement. Here we use the **END_DETECTION** message received at the end of the detection process to set **serial_detected** variable.

Also, after the END_DETECTION message, we do a research into the routing table.

:::info
The routing table is a structure that has all the information about the nodes and services that exist in a system. Each service can recognize the ocharacteristics of the others, by filtering the data of the routing table, and find the services that it wants to communicate.
:::

So here we need to keep the id of a led, so we search in the routing table for the alias of the led, “led_service” and then the pipe, by filtering the services of type “PIPE”.

Next to that, the code is pretty straightforward, we receive an array filled with letters to encode and we iterate on this array to encode each letter. We can detect the end of the word with the character **\r**.

Notice that we created a specific **CMD** to manage these datas, its used to filter messages in the handler and only process this type of messages.

The **Encode_DecodeLetter** routine is a simple **switch / case** used to match received characters with morse sequences:

```c
MorseLetter *Encoder_DecodeLetter(char letter);
...
/******************************************************************************
 * @brief decode received letters
 * @param letter to decode
 * @return MorseLetter pointer
 ******************************************************************************/
MorseLetter *Encoder_DecodeLetter(char letter)
{
    switch (letter)
    {
        case 'a':
            return &a_letter;
        case 'b':
            return &b_letter;
        case 'c':
            return &c_letter;
        case 'd':
            return &d_letter;
        case 'e':
            return &e_letter;
        case 'f':
            return &f_letter;
        case 'g':
            return &g_letter;
        case 'h':
            return &h_letter;
        case 'i':
            return &i_letter;
        case 'j':
            return &j_letter;
        case 'k':
            return &k_letter;
        case 'l':
            return &l_letter;
        case 'm':
            return &m_letter;
        case 'n':
            return &n_letter;
        case 'o':
            return &o_letter;
        case 'p':
            return &p_letter;
        case 'q':
            return &q_letter;
        case 'r':
            return &r_letter;
        case 's':
            return &s_letter;
        case 't':
            return &t_letter;
        case 'u':
            return &u_letter;
        case 'v':
            return &v_letter;
        case 'w':
            return &w_letter;
        case 'x':
            return &x_letter;
        case 'y':
            return &y_letter;
        case 'z':
            return &z_letter;
        default:
            return 0;
    }
}
```

## Next Step

Here we are, we finished the decoder service. If you don’t add a service pipe and build this project, you should see **S.O.S** sequence blinking on your board.

In the next step, you will integrate a Pipe service, and you will send your own words, to encode them in morse code.
