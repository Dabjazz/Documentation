---
custom_edit_url: null
---

import Image from '/src/components/Images.js';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Part 2: Create an App : Encoder

## 1. Introduction

Now that we have a Led driver, we will develop the encoder service. The goal is to receive a message from a serial service containing a word with few letters, translate these letters into Morse sequences, and send these sequences to the LED.

<div align="center">
  <Image
    src="/img/tutorials/morse/morse-2-1.png"
    darkSrc="/img/tutorials/morse/morse-2-1-dark.png"
  />
</div>

## 2. Create the encoder service

First, create a dedicated folder in the */lib* repository with two blanked files:

```bash
cd ./lib/
mkdir Encoder/
cd Encoder/
touch encoder.c encoder.h
```

You can also create it by click right and **new_file** in the *Encoder* folder, in the project explorer of VSCode:

<div align="center">
  <Image src="/img/tutorials/morse/morse-2-2.png" />
</div>

Then open *encoder.h* and copy the following code:

```c
/******************************************************************************
 * @file encoder
 * @brief encoder app
 * @author Luos
 * @version 0.0.0
 ******************************************************************************/
#ifndef ENCODER_H
#define ENCODER_H

#include "luos.h"
#include "stdbool.h"

/*******************************************************************************
 * Definitions
 ******************************************************************************/

/*******************************************************************************
 * Variables
 ******************************************************************************/

/*******************************************************************************
 * Function
 ******************************************************************************/
void Encoder_Init(void);
void Encoder_Loop(void);

#endif /* ENCODER_H */
```

We just declared two functions used to run the service as we did for the LED. Now we will create two implementations for them. Open the file *encoder.c* and copy the following code:

```c
/******************************************************************************
 * @file encoder
 * @brief encoder app
 * @author Luos
 * @version 0.0.0
 ******************************************************************************/

#include "encoder.h"

/*******************************************************************************
 * Definitions
 ******************************************************************************/

/*******************************************************************************
 * Variables
 ******************************************************************************/
service_t *service;

/*******************************************************************************
 * Function
 ******************************************************************************/
void Encoder_MsgHandler(service_t *service, msg_t *msg);

/******************************************************************************
 * @brief init must be call in project init
 * @param None
 * @return None
 ******************************************************************************/
void Encoder_Init(void)
{
    // service initialization
    revision_t revision = {.major = 1, .minor = 0, .build = 0};
    // Service creation following state profile
    service = Luos_CreateService(Encoder_MsgHandler, LUOS_LAST_TYPE, "encoder_service", revision);
}

/******************************************************************************
 * @brief loop must be call in project loop
 * @param None
 * @return None
 ******************************************************************************/
void Encoder_Loop(void)
{
}

/******************************************************************************
 * @brief manage messages send to the service
 * @param Service which send the message
 * @param msg which send the message
 * @return None
 ******************************************************************************/
void Encoder_MsgHandler(service_t *service, msg_t *msg)
{
}
```

All this code is very similar to the previous chapter, you can check its steps for more information. You can run this new service by calling its API in the **main** file:

```c
/******************************************************************************
 * @brief main function
 * @param None
 * @return None
 ******************************************************************************/
int main(void)
{
    HAL_Init();
    SystemClock_Config();

    // Init
    Luos_Init();
    Led_Init();
    Encoder_Init();
    while (1)
    {
        // Loop
        Luos_Loop();
        Led_Loop();
        Encoder_Loop();
    }
}
```

## 3. Send a Luos message

Now, we will create Morse sequences from letters and send them to the Led service. We first need a function to create and send Luos messages. Open *encoder.c* and add the following in the function section:

```c
/*******************************************************************************
 * Function
 ******************************************************************************/
void Encoder_SendMorse(bool state);
```

Then copy the following code at the end of the file:

```c
/******************************************************************************
 * @brief send a luos message to the led
 * @param State to send to the led
 * @return None
 ******************************************************************************/
void Encoder_SendMorse(bool state)
{
    // Now send a message
    if (id_led > 0)
    {
        msg_t led_msg;
        led_msg.header.target = id_led;
        led_msg.header.cmd = IO_STATE;
        led_msg.header.target_mode = IDACK;
        led_msg.header.size = sizeof(char);
        led_msg.data[0] = state;
        Luos_SendMsg(service, &led_msg);
    }
}
```

The argument **state** is used to light **ON/OFF** the LED, then we create a **msg_t** variable which will be filled with several pieces of information:

- `target`: all services have an **ID**. We will give here the ID of the message target.
- `cmd`: this field gives information about the data we send.
- `target_mode`: low-level Luos internal command, giving information about how the message will be managed.
- `size`: the size of the sent data.
- `data[128]`: an array used to store data to send.

Once the message is created, we can send it with the `Luos_SendMsg` routine. It only needs a pointer to the sending service and the message to send.

There is one remaining problem: how can we find the ID of the target service? Luos gives you a routine to do this too, called the routing table filtering method. We will explain this mechanism in the next steps, when defining the `led_id`.

## 4. Play a Morse letter

Now we will use our new function to create Morse sequences for each letter in the alphabet. In Morse code, each letter can be broken down in several ON / OFF LED states and the duration of these states can be found in the page [Morse code - Wikipedia](https://en.wikipedia.org/wiki/Morse_code).

We will create structures to store these states for each letter. First, add the following code in *encoder.h*:

```c
/*******************************************************************************
 * Definitions
 ******************************************************************************/
#define SHORT_PERIOD 300

typedef enum WordLength
{
    SHORT      = SHORT_PERIOD,
    LONG       = 3 * SHORT_PERIOD,
    WORD_SPACE = 7 * SHORT_PERIOD,
} WordLength;

typedef struct MorseElement
{
    union
    {
        struct
        {
            uint16_t state;
            uint16_t word_length;
        };
        uint32_t value;
    };
} MorseElement;

typedef struct MorseLetter
{
    union
    {
        MorseElement morse_element[10];
        uint32_t value;
    };
} MorseLetter;
```

Then, add a new file in */lib/encoder*:

```bash
touch dictionnary.h
```

Ccopy the following code in it:

```c
/******************************************************************************
 * @file dictionnary
 * @brief morse dictionnary
 * @author Luos
 * @version 0.0.0
 ******************************************************************************/
#ifndef DICTIONNARY_H
#define DICTIONNARY_H

#include "encoder.h"

/*******************************************************************************
 * Definitions
 ******************************************************************************/
#define LETTER_END 0xFFFFFFF1

/*******************************************************************************
 * Variables
 ******************************************************************************/
MorseLetter a_letter = {
    .morse_element[0]       = {.state = true, .word_length = SHORT},
    .morse_element[1]       = {.state = false, .word_length = SHORT},
    .morse_element[2]       = {.state = true, .word_length = LONG},
    .morse_element[3]       = {.state = false, .word_length = SHORT},
    .morse_element[4].value = LETTER_END,
};

MorseLetter b_letter = {
    .morse_element[0]       = {.state = true, .word_length = LONG},
    .morse_element[1]       = {.state = false, .word_length = SHORT},
    .morse_element[2]       = {.state = true, .word_length = SHORT},
    .morse_element[3]       = {.state = false, .word_length = SHORT},
    .morse_element[4]       = {.state = true, .word_length = SHORT},
    .morse_element[5]       = {.state = false, .word_length = SHORT},
    .morse_element[6]       = {.state = true, .word_length = SHORT},
    .morse_element[7]       = {.state = false, .word_length = SHORT},
    .morse_element[8].value = LETTER_END,
};

MorseLetter c_letter = {
    .morse_element[0]       = {.state = true, .word_length = LONG},
    .morse_element[1]       = {.state = false, .word_length = SHORT},
    .morse_element[2]       = {.state = true, .word_length = SHORT},
    .morse_element[3]       = {.state = false, .word_length = SHORT},
    .morse_element[4]       = {.state = true, .word_length = LONG},
    .morse_element[5]       = {.state = false, .word_length = SHORT},
    .morse_element[6]       = {.state = true, .word_length = SHORT},
    .morse_element[7]       = {.state = false, .word_length = SHORT},
    .morse_element[8].value = LETTER_END,
};

...
```

You can find the complete code in the github repository. Now, add the following function in the file *encoder.c*:

```c
uint8_t morse_state          = false;
WordLength morse_period      = 0;
uint32_t morse_start_timeout = 0;
uint16_t element_index       = 0;
bool end_of_letter           = true;

...

void Encoder_PlayLetter(MorseLetter *letter);

...

/******************************************************************************
 * @brief Play a letter sequence
 * @param None
 * @return None
 ******************************************************************************/
void Encoder_PlayLetter(MorseLetter *letter)
{
    // for each element in a letter
    if ((letter->morse_element[element_index].value != LETTER_END) & !end_of_letter)
    {
        if (Luos_GetSystick() - morse_start_timeout > morse_period)
        {
            morse_state  = letter->morse_element[element_index].state;
            morse_period = letter->morse_element[element_index].word_length;
            // send new led state
            Encoder_SendMorse(morse_state);
            // wait for the time period
            morse_start_timeout = Luos_GetSystick();
            // go to the next element
            element_index += 1;
        }
    }
    else
    {
        // reset element index and go to the next letter
        element_index = 0;
        end_of_letter = true;
    }
}
```

We will not dig into this code too much because it is not the purpose of this tutorial. Just notice that this function iterates over each line contained in the letter and stops when it detects the `LETTER_END` constant.

## 5. Play a Morse word

The next step is straightforward, we will use `Encoder_PlayLetter` to create sequences for words.

First, create the word's structure into the file *encoder.h*:

```c
...
typedef struct MorseWord
{
    MorseLetter *morse_letter[10];
} MorseWord;
```

Add the following in *dictionnary.h*:

```c
/*******************************************************************************
 * Definitions
 ******************************************************************************/
#define LETTER_END 0xFFFFFFF1
#define WORD_END   0xFFFFFFF2

/*******************************************************************************
 * Variables
 ******************************************************************************/
MorseLetter end_word_marker = {
    .value = WORD_END};

MorseLetter end_letter = {
    .morse_element[0]       = {.state = false, .word_length = WORD_SPACE - SHORT},
    .morse_element[1].value = LETTER_END,
};
```

`end_letter` is used to wait between two words. `WORD_END` is used to detect the end of a word in the `Encoder_PlayWord()` routine, which we will add in *encoder.c*:

```c
...

uint16_t element_index       = 0;
uint16_t letter_index        = 0;
bool end_of_word             = false;
bool end_of_letter           = true;

...

void Encoder_PlayWord(MorseWord *morse_word);

...

/******************************************************************************
 * @brief Play a word
 * @param None
 * @return None
 ******************************************************************************/
void Encoder_PlayWord(MorseWord *morse_word)
{
    // send a word sequence
    if ((morse_word->morse_letter[letter_index]->value != WORD_END) & !end_of_word)
    {
        Encoder_PlayLetter(morse_word->morse_letter[letter_index]);

        if (end_of_letter)
        {
            end_of_letter = false;
            letter_index += 1;
        }
    }
    else
    {
        // end of word
        letter_index = 0;
        end_of_word  = true;
    }
}
```

## 6. Detect serial service

We will now add this `Encoder_PlayWord()` routine in `Encoder_Loop`. Our service will have two operating modes:

1. If it detects the presence of the serial service, it will play the Morse words received from it.
2. If not, it will play the S.O.S. sequence.

To do this, we will use Luos functions:

```c
MorseWord receive_word;

MorseWord sos_table = {
    .morse_letter[0] = &s_letter,
    .morse_letter[1] = &o_letter,
    .morse_letter[2] = &s_letter,
    .morse_letter[3] = &end_letter,
    .morse_letter[4] = &end_word_marker,
};

bool serial_detected = false;

/******************************************************************************
 * @brief loop must be call in project loop
 * @param None
 * @return None
 ******************************************************************************/
void Encoder_Loop(void)
{
    if (Luos_IsNodeDetected())
    {
        if (serial_detected)
        {
            Encoder_PlayWord(&receive_word);
        }
        else
        {
            end_of_word = false;
            Encoder_PlayWord(&sos_table);
        }
    }
}
```

:::info
Notice that we use `Luos_IsNodeDetected()`: this function checks if the node is connected to the Luos network. We use this function to avoid running the service's `loop()` function if the node is not connected.
:::

All services have to be connected to the Luos network to send and receive messages. For services to be connected and recognized in the network, we have to launch a detection. We do that by adding the following line in the `Encoder_Init()` function:

```c
void Encoder_Init(void)
{
    // service initialization
    revision_t revision = {.major = 1, .minor = 0, .build = 0};
    // Service creation following state profile
    service = Luos_CreateService(Encoder_MsgHandler, LUOS_LAST_TYPE, "encoder_service", revision);
    // Detect all services of your network and create a routing_table
    Luos_Detect(service);

    // initialize variables
    morse_state         = false;
    morse_period        = 0;
    morse_start_timeout = 0;
    element_index       = 0;
    letter_index        = 0;
    end_of_letter       = true;
    end_of_word         = true;
}
```

`Luos_Detect()` launches the detection, and its end can be detected with `Luos_IsConnected()`: once the node is connected, the function returns **True**. After that, all services can send and receive messages.

We added some initialization code too to set default values for variables.

## 7. Receive a custom message from serial service

One last thing, we have to manage the messages received from the serial service to update the `received_word` variable. As seen in the tutorial for the LED service, messages received by the encoder are handled by `Encoder_MsgHandler()`. Let's add the following code in *encoder.c*:

```c
/******************************************************************************
 * @brief manage messages send to the service
 * @param Service which send the message
 * @param msg which send the message
 * @return None
 ******************************************************************************/
void Encoder_MsgHandler(service_t *service, msg_t *msg)
{
    uint16_t index          = 0;
    uint8_t received_letter = 0;

    if (msg->header.cmd == SET_CMD)
    {
        while (msg->data[index] != '\r')
        {
            receive_word.morse_letter[index] = Encoder_DecodeLetter(msg->data[index]);
            index += 1;
        }
        receive_word.morse_letter[index]     = &end_letter;
        receive_word.morse_letter[index + 1] = &end_word_marker;

        end_of_word = false;
        end_of_letter = false;
    }

		if (msg->header.cmd == END_DETECTION)
    {
        search_result_t result;
        RTFilter_Alias(RTFilter_Reset(&result), "led_service");
        id_led = result.result_table[0]->id;
        RTFilter_Type(RTFilter_Reset(&result), PIPE_TYPE);
        if (result.result_nbr > 0)
        {
            time_luos_t update_time = 0.01;
            msg_t update_msg;
            update_msg.header.target      = result.result_table[0]->id;
            update_msg.header.target_mode = IDACK;
            TimeOD_TimeToMsg(&update_time, &update_msg);
            update_msg.header.cmd = UPDATE_PUB;
            Luos_SendMsg(service, &update_msg);
            serial_detected = true;
            return;
        }
        serial_detected = false;
    }
}
```

First, please pay attention to the second `if` statement. Here we use the `END_DETECTION` message received at the end of the detection process to set the `serial_detected` variable.

Also, after the `END_DETECTION` message, we do a research into the routing table.

:::info
The routing table is a structure that has all the information about the nodes and services that exist in a system. Each service can recognize the characteristics of the others, by filtering the data of the routing table, and find the services that it wants to communicate with.
:::

Here, we need to keep the id of a LED, so we search in the routing table for the alias of the LED, `led_service`, and then the pipe's alias by filtering the services of type `PIPE`.

Then, the code is pretty straightforward: we receive an array filled with letters to be encoded, and we iterate on this array to encode each letter. We can detect the end of the word with the character `\r`.

Notice that we created a specific `CMD` to manage this data; it is used to filter messages in the handler and process this type of messages only.

The `Encode_DecodeLetter()` routine is a simple **switch / case** used to match the received characters with morse sequences:

```c
MorseLetter *Encoder_DecodeLetter(char letter);
...
/******************************************************************************
 * @brief decode received letters
 * @param letter to decode
 * @return MorseLetter pointer
 ******************************************************************************/
MorseLetter *Encoder_DecodeLetter(char letter)
{
    switch (letter)
    {
        case 'a':
            return &a_letter;
        case 'b':
            return &b_letter;
        case 'c':
            return &c_letter;
        case 'd':
            return &d_letter;
        case 'e':
            return &e_letter;
        case 'f':
            return &f_letter;
        case 'g':
            return &g_letter;
        case 'h':
            return &h_letter;
        case 'i':
            return &i_letter;
        case 'j':
            return &j_letter;
        case 'k':
            return &k_letter;
        case 'l':
            return &l_letter;
        case 'm':
            return &m_letter;
        case 'n':
            return &n_letter;
        case 'o':
            return &o_letter;
        case 'p':
            return &p_letter;
        case 'q':
            return &q_letter;
        case 'r':
            return &r_letter;
        case 's':
            return &s_letter;
        case 't':
            return &t_letter;
        case 'u':
            return &u_letter;
        case 'v':
            return &v_letter;
        case 'w':
            return &w_letter;
        case 'x':
            return &x_letter;
        case 'y':
            return &y_letter;
        case 'z':
            return &z_letter;
        default:
            return 0;
    }
}
```

## Next Step

Here we are, we finished the decoder service. If you don't add a pipe service and build this project, you should see the **S.O.S.** sequence blinking on your board.

In the next step, you will integrate a pipe service, and you will send your own words to be encoded in Morse code.
