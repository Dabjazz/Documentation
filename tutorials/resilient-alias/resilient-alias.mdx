---
custom_edit_url: null
---

import Image from '@site/src/components/Images.js';


# Resilient aliases management.

Luos allow you to deal with service alias. Aliases are really more practical than id and allow developers to naturally find and access a specific service somewhere on the network.

In some development, you will need to have multiple times the same service. For example, if you are making a robot with multiple motors you could have multiple times the exact same board running the exact same firmware at different places on your device.

But the same way id needs to be unique your aliases need to be different too to be findable on your system.

Luos allow you to avoid creating a new binary for all of your boards and give you the possibility to customize the aliases as you want in a really practical way.

:::info
You can find an example of Resilient aliases management here : TODO
:::

# How alias are managed

Every service needs an Alias. Basically, when you create your service you will have to define your service default Alias.

After this creation, your alias may be modified in different ways.

 1. If you have multiple times the same service alias on a device, Luos will add a number at the end of your alias depending on their position from the node performing the detection. This guarantees aliases unicity. This modification is regenerated at each detection, so this new alias may change if another detection occurs from another node. This alias is not saved on the service, only on the routing table, and it’s not persistent at all.

1. Users can choose to rename an existing service by sending a custom alias request from another service. This allows you to keep your name consistent even in case of new detection and to choose a practical alias such as “left_motor” or “front_sensor”. This alias is saved on the service, but not on the routing table, you will have to remake a detection to update the routing table with the new alias.

In this second situation, we obtain customization of the Alias less volatile, but this information is still not persistent to hard reset or power off.

In this tutorial, we will discover how to make alias persistent to reboot, and even to flash.

# Saving aliases

To make the alias resilient we will need to save the alias information in flash or EEPROM. Depending on your hardware specificities you may have different ways to read and write into your memory. You could use this function to store some other parameters such as configuration or calibrations values for your project, have direct flash access, or use a file system!

Luos provide you with a flexible solution allowing you to optionally save your aliases in the best way possible for your project.

Let’s see how to make it!

## Default aliases

In any case, you need to define a default alias at service creation. This is mandatory, and this alias will be used as a backup if your custom alias is removed.

Let’s use a simple led as an example. In the package init, you need to create your service with the associated alias :

```c
void Led_Init(void)
{
    // Initialization of Led gpio...
    // Create the Led service
    revision_t revision = {.major = 1, .minor = 0, .build = 0};
    Luos_CreateService(Led_MsgHandler, STATE_TYPE, "led", revision);
}
```

As you can see here we just created an on/off led service called `led`.

If you run this service somewhere, other services will be able to rename it using a `WRITE_ALIAS` command message containing a new alias. The easiest way to test it is to use a Gate service connected with pyluos. After running `pyluos-shell`, if you print `device.nodes` you should see

```
  ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
  ┃  ╭node 1            /!\ Not certified            ┃
  ┃  │  Type                Alias               ID   ┃
  ┃  ├> Gate                gate                1    ┃
  ┃  ╰> Pipe                Pipe                2    ┃
╔>┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
║     ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
╚══ 0>┃0 ╭node 2            /!\ Not certified            ┃
      ┃  │  Type                Alias               ID   ┃
      ┃  ╰> State               led                 3    ┃
     >┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
```

As you can see here we see our led aliased service.

## Custom alias

Now, in your `pyluos-shell` console if you make :

```python
device.custom_led.rename("custom led")
```

Then relaunch `pyluos-shell` and print `device.nodes` you should see

```
  ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
  ┃  ╭node 1            /!\ Not certified            ┃
  ┃  │  Type                Alias               ID   ┃
  ┃  ├> Gate                gate                1    ┃
  ┃  ╰> Pipe                Pipe                2    ┃
╔>┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
║     ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
╚══ 0>┃0 ╭node 2            /!\ Not certified            ┃
      ┃  │  Type                Alias               ID   ┃
      ┃  ╰> State               custom_led          3    ┃
     >┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
```

As you can see, the service saved your alias and replace the space with a ‘_’. Also if you try to send a too long alias it will be truncated.

warning : If you send character different from A to z, 0 to 9, space or ‘_’ your alias will be rejected and not saved.

Now, in your `pyluos-shell` console if you make :

```python
device.custom_led.rename("")
```

Then relaunch `pyluos-shell` and print `device.nodes` you should see

```
  ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
  ┃  ╭node 1            /!\ Not certified            ┃
  ┃  │  Type                Alias               ID   ┃
  ┃  ├> Gate                gate                1    ┃
  ┃  ╰> Pipe                Pipe                2    ┃
╔>┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
║     ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
╚══ 0>┃0 ╭node 2            /!\ Not certified            ┃
      ┃  │  Type                Alias               ID   ┃
      ┃  ╰> State               led                 3    ┃
     >┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
```

As you can see your default alias is back! You can remove your custom alias by sending a void string.

## How to save custom alias

When a service receive a `WRITE_ALIAS` command, Luos save the alias then passes the message to the service. This means that you can get this message into the `Led_MsgHandler` callback save this new alias somewhere.

for example :

```c
static void Led_MsgHandler(service_t *service, msg_t *msg)
{
     ...
    if (msg->header.cmd == WRITE_ALIAS)
    {
        Alias_write(addressToWriteIt, msg->data, msg->header.size);
    }
}
```

By saving this alias on a non-volatile memory you will be able to get back this new alias even after a reboot or a program flash of your MCU.

To update the alias after a reboot, you can use the `Luos_UpdateAlias` function :

```c
void Led_Init(void)
{
    // Initialization of Led gpio...
    // Create the Led service
    revision_t revision = {.major = 1, .minor = 0, .build = 0};
    service_t *myService = Luos_CreateService(Led_MsgHandler, STATE_TYPE, "led", revision);
        // Get back the saved alias.
        char saved_alias[MAX_ALIAS_SIZE];
        int size = Alias_read(addressToReadIt, saved_alias);
    // Update the Alias
        Luos_UpdateAlias(myService, saved_alias, size);
}
```

## How to save aliases for multiple packages

The main concept of Luos is to keep services and packages loosely coupled. This means that your package should have everything needed locally and don’t depend on any code somewhere else.

If you have multiple packages on a node and if you want to be able to save your aliases on all those packages, you may want to have a common function used by all the packages to store aliases. In this case, we advise you to consider your memory management functions as a library and to make your package dependent on this library.

:::info
You can find an example of Resilient aliases management as a lib here : TODO
:::
